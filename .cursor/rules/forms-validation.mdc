---
title: Forms Validation Best Practices
description: Guidelines for implementing form validation in React applications using react-hook-form and Zod
alwaysApply: true
---

# Forms Validation Best Practices

## Overview

AssetCore implements comprehensive form validation using react-hook-form, Zod schemas, and shadcn/ui components. This approach ensures type-safe form handling, consistent validation patterns, and excellent user experience across all forms in the application.

### Key Features

- **Type-Safe Forms**: TypeScript integration with Zod schema validation
- **Client & Server Validation**: Shared validation schemas between frontend and backend
- **Dynamic Form Fields**: Support for dynamic arrays and conditional fields
- **Error Handling**: Comprehensive error handling with user-friendly messages
- **Performance**: Optimized form performance with minimal re-renders

### Technology Stack

- **react-hook-form**: Performant form state management
- **Zod**: TypeScript-first schema validation
- **shadcn/ui**: Accessible form components
- **@hookform/resolvers**: Integration between react-hook-form and Zod

## Dynamic Form Fields

```typescript
// ✅ CORRECT: Dynamic form fields with react-hook-form

'use client';

import { useForm, useFieldArray } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Plus, Trash2 } from 'lucide-react';

const componentSchema = z.object({
  type: z.string().min(1, 'Component type is required'),
  serialNumber: z.string().min(1, 'Serial number is required'),
  position: z.string().optional(),
});

const assetWithComponentsSchema = z.object({
  assetCode: z.string().min(1),
  type: z.string().min(1),
  components: z.array(componentSchema).min(1, 'At least one component is required'),
});

type AssetWithComponentsForm = z.infer<typeof assetWithComponentsSchema>;

export function AssetWithComponentsForm() {
  const form = useForm<AssetWithComponentsForm>({
    resolver: zodResolver(assetWithComponentsSchema),
    defaultValues: {
      assetCode: '',
      type: '',
      components: [{ type: '', serialNumber: '', position: '' }],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control: form.control,
    name: 'components',
  });

  async function onSubmit(data: AssetWithComponentsForm) {
    const response = await fetch('/api/assets/with-components', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error('Failed to create asset');
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* Asset fields */}
        <FormField
          control={form.control}
          name="assetCode"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Asset Code</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Dynamic component fields */}
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-medium">Components</h3>
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => append({ type: '', serialNumber: '', position: '' })}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Component
            </Button>
          </div>

          {fields.map((field, index) => (
            <div key={field.id} className="flex gap-4 items-start border p-4 rounded-lg">
              <div className="flex-1 space-y-4">
                <FormField
                  control={form.control}
                  name={`components.${index}.type`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Type</FormLabel>
                      <FormControl>
                        <Input placeholder="engine" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name={`components.${index}.serialNumber`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Serial Number</FormLabel>
                      <FormControl>
                        <Input placeholder="SN-12345" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name={`components.${index}.position`}
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Position (Optional)</FormLabel>
                      <FormControl>
                        <Input placeholder="left_front" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>

              <Button
                type="button"
                variant="destructive"
                size="icon"
                onClick={() => remove(index)}
                disabled={fields.length === 1}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          ))}
        </div>

        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Creating...' : 'Create Asset with Components'}
        </Button>
      </form>
    </Form>
  );
}
```

## Server-Side Validation

```typescript
// ✅ CORRECT: Handle server-side validation errors

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const assetSchema = z.object({
  assetCode: z.string().min(1, 'Asset code is required').max(100),
  type: z.string().min(1, 'Type is required'),
});

type AssetFormData = z.infer<typeof assetSchema>;

export function AssetForm() {
  const form = useForm<AssetFormData>({
    resolver: zodResolver(assetSchema),
  });

  async function onSubmit(data: AssetFormData) {
    try {
      const response = await fetch('/api/assets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const error = await response.json();
        
        // Handle field-specific errors from server
        if (error.details) {
          error.details.forEach((err: any) => {
            form.setError(err.field as keyof AssetFormData, {
              type: 'server',
              message: err.message,
            });
          });
          return;
        }
        
        // Handle general form error
        form.setError('root', {
          type: 'server',
          message: error.message || 'Failed to create asset',
        });
        return;
      }

      // Success handling
      const asset = await response.json();
      router.push(`/assets/${asset.id}`);
      
    } catch (error) {
      form.setError('root', {
        type: 'server',
        message: 'An unexpected error occurred',
      });
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* Form fields */}
        
        {/* Display root error */}
        {form.formState.errors.root && (
          <div className="text-sm text-destructive">
            {form.formState.errors.root.message}
          </div>
        )}
        
        <Button type="submit" disabled={form.formState.isSubmitting}>
          Submit
        </Button>
      </form>
    </Form>
  );
}
```

## Reusable Form Schemas

```typescript
// ✅ CORRECT: Share schemas between client and server

// lib/db/validation/schemas.ts
import { z } from 'zod';

// Define reusable schemas
export const assetInsertSchema = z.object({
  assetCode: z.string().min(1, 'Asset code is required').max(100),
  type: z.string().min(1, 'Type is required').max(100),
  model: z.string().max(255).optional(),
  status: z.enum(['operational', 'inactive', 'maintenance']).default('operational'),
  description: z.string().max(500).optional(),
});

export const componentInsertSchema = z.object({
  serialNumber: z.string().min(1, 'Serial number is required').max(255),
  type: z.string().min(1, 'Type is required').max(100),
  position: z.string().max(100).optional(),
  notes: z.string().optional(),
});

export const ticketCreateSchema = z.object({
  componentId: z.string().uuid('Invalid component ID'),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  description: z.string().min(10, 'Description must be at least 10 characters'),
  attachments: z.array(z.string().url()).optional(),
});

// Export types
export type AssetInsert = z.infer<typeof assetInsertSchema>;
export type ComponentInsert = z.infer<typeof componentInsertSchema>;
export type TicketCreate = z.infer<typeof ticketCreateSchema>;

// Use in API route
// app/api/assets/route.ts
import { assetInsertSchema } from '@/lib/db/validation/schemas';
import { createAsset } from '@/lib/db/repositories/asset-repository';

export async function POST(request: NextRequest) {
  const body = await request.json();
  
  // Validate with same schema used in frontend
  const validationResult = assetInsertSchema.safeParse(body);
  
  if (!validationResult.success) {
    return NextResponse.json(
      { error: 'Invalid input', details: validationResult.error.errors },
      { status: 400 }
    );
  }
  
  // Use validated data
  const asset = await createAsset(context, validationResult.data);
  return NextResponse.json(asset, { status: 201 });
}

// Use in form component
// components/forms/AssetForm.tsx
import { assetInsertSchema } from '@/lib/db/validation/schemas';

const form = useForm({
  resolver: zodResolver(assetInsertSchema),
});
```

## Advanced Zod Patterns

```typescript
// ✅ CORRECT: Complex Zod validations

// Custom refinements
const ticketSchema = z.object({
  componentId: z.string().uuid(),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  description: z.string().min(10, 'Description must be at least 10 characters'),
  scheduledDate: z.string().datetime().optional(),
}).refine(
  (data) => {
    // If priority is critical, description must be longer
    if (data.priority === 'critical' && data.description.length < 50) {
      return false;
    }
    return true;
  },
  {
    message: 'Critical tickets require detailed description (50+ characters)',
    path: ['description'],
  }
);

// Conditional validation
const maintenanceSchema = z.object({
  maintenanceType: z.enum(['immediate', 'scheduled']),
  description: z.string().min(10),
  scheduledDate: z.string().datetime().optional(),
  cost: z.number().positive().optional(),
}).superRefine((data, ctx) => {
  // Scheduled maintenance requires scheduled_date
  if (data.maintenanceType === 'scheduled' && !data.scheduledDate) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Scheduled date is required for scheduled maintenance',
      path: ['scheduledDate'],
    });
  }
  
  // Scheduled date must be in future
  if (data.scheduledDate && new Date(data.scheduledDate) < new Date()) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Scheduled date must be in the future',
      path: ['scheduledDate'],
    });
  }
});

// Transform and coerce
const assetUpdateSchema = z.object({
  assetCode: z.string().min(1).max(100).trim().toUpperCase(), // Transform to uppercase
  type: z.string().min(1).toLowerCase(), // Transform to lowercase
  status: z.enum(['operational', 'inactive', 'maintenance']),
  cost: z.string().transform((val) => parseFloat(val)), // Coerce string to number
});

// Union types for different scenarios
const createOrUpdateAssetSchema = z.discriminatedUnion('action', [
  z.object({
    action: z.literal('create'),
    assetCode: z.string().min(1),
    type: z.string().min(1),
  }),
  z.object({
    action: z.literal('update'),
    id: z.string().uuid(),
    assetCode: z.string().min(1).optional(),
    type: z.string().min(1).optional(),
  }),
]);

// Nested object validation
const assetWithComponentsSchema = z.object({
  asset: z.object({
    assetCode: z.string().min(1),
    type: z.string().min(1),
  }),
  components: z.array(
    z.object({
      type: z.string().min(1),
      serialNumber: z.string().min(1),
      position: z.string().optional(),
    })
  ).min(1, 'At least one component is required'),
});

// Date validation
const dateRangeSchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
}).refine(
  (data) => new Date(data.endDate) > new Date(data.startDate),
  {
    message: 'End date must be after start date',
    path: ['endDate'],
  }
);

// Partial updates (make all fields optional)
const assetUpdateSchema = assetInsertSchema.partial();

// Pick specific fields
const assetStatusUpdateSchema = assetInsertSchema.pick({ status: true });

// Omit fields
const assetWithoutDatesSchema = assetInsertSchema.omit({ createdAt: true, updatedAt: true });
```

## Error Handling

```typescript
// ✅ CORRECT: Comprehensive error handling in forms

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useToast } from '@/components/ui/use-toast';

export function TicketForm() {
  const { toast } = useToast();
  const form = useForm<TicketFormValues>({
    resolver: zodResolver(ticketSchema),
  });

  async function onSubmit(data: TicketFormValues) {
    try {
      const response = await fetch('/api/tickets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (!response.ok) {
        // Handle specific error codes
        if (response.status === 400) {
          // Validation errors from server
          if (result.details && Array.isArray(result.details)) {
            result.details.forEach((error: { path: string[]; message: string }) => {
              const field = error.path.join('.') as keyof TicketFormValues;
              form.setError(field, {
                type: 'server',
                message: error.message,
              });
            });
          } else {
            form.setError('root', {
              type: 'server',
              message: result.error || 'Validation failed',
            });
          }
          return;
        }

        if (response.status === 409) {
          // Conflict error (duplicate)
          toast({
            variant: 'destructive',
            title: 'Duplicate Entry',
            description: result.error,
          });
          return;
        }

        // Generic server error
        throw new Error(result.error || 'Failed to create ticket');
      }

      // Success
      toast({
        title: 'Success',
        description: 'Ticket created successfully',
      });

      form.reset();
      router.push(`/tickets/${result.id}`);

    } catch (error) {
      console.error('Form submission error:', error);
      toast({
        variant: 'destructive',
        title: 'Error',
        description: error instanceof Error ? error.message : 'An unexpected error occurred',
      });
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* Form fields */}

        {/* Display root-level errors */}
        {form.formState.errors.root && (
          <div className="rounded-lg bg-destructive/10 p-4 text-sm text-destructive">
            {form.formState.errors.root.message}
          </div>
        )}

        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Submitting...' : 'Submit Ticket'}
        </Button>
      </form>
    </Form>
  );
}
```

## Best Practices

```typescript
// ✅ DO: Use Zod for validation
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

// ✅ DO: Infer types from Zod schemas
type FormData = z.infer<typeof schema>;

// ✅ DO: Handle loading states
<Button disabled={form.formState.isSubmitting}>
  {form.formState.isSubmitting ? 'Saving...' : 'Save'}
</Button>

// ✅ DO: Show validation errors
<FormMessage /> // shadcn/ui automatically shows errors

// ✅ DO: Reset form after successful submission
form.reset();

// ✅ DO: Set default values
const form = useForm({
  defaultValues: {
    assetCode: '',
    status: 'operational', // Set sensible defaults
  },
});

// ✅ DO: Handle server-side errors
if (!response.ok) {
  const error = await response.json();
  form.setError('root', { message: error.message });
}

// ✅ DO: Use TanStack Query for form mutations
const createAsset = useCreateAsset(); // From custom hook
const onSubmit = (data) => createAsset.mutate(data);

// ❌ DON'T: Mix controlled and uncontrolled inputs
// Use either react-hook-form OR plain inputs, not both

// ❌ DON'T: Forget to handle errors
// Always wrap async operations in try-catch

// ❌ DON'T: Validate only on client
// Always validate on server too (using same Zod schema)

// ❌ DON'T: Forget to disable submit button
// Show loading state during submission
```

## Implementation Guidelines

### Form Component Structure

AssetCore follows a consistent pattern for form components:

1. **Schema Definition**: Define Zod schemas in shared validation files
2. **Type Inference**: Use `z.infer<typeof schema>` for TypeScript types
3. **Form Setup**: Configure react-hook-form with zodResolver
4. **Error Handling**: Implement comprehensive error handling
5. **Loading States**: Show appropriate loading states during submission

### File Organization

```
src/
├── lib/
│   └── validation/
│       ├── schemas.ts          # Shared Zod schemas
│       └── types.ts           # Inferred TypeScript types
├── components/
│   └── forms/
│       ├── AssetForm.tsx      # Asset creation/editing forms
│       ├── ComponentForm.tsx  # Component management forms
│       └── MaintenanceForm.tsx # Maintenance record forms
└── app/
    └── api/
        └── [endpoint]/
            └── route.ts       # API routes with server-side validation
```

### Validation Patterns

- **Client-Side**: Immediate feedback with Zod validation
- **Server-Side**: Same schemas used for API validation
- **Error Display**: Consistent error messaging across forms
- **Field Validation**: Real-time validation with debounced input

## Summary

**Key Principles:**

1. ✅ Use react-hook-form + Zod + shadcn/ui for all forms
2. ✅ Share validation schemas between client and server
3. ✅ Use TypeScript types inferred from Zod schemas
4. ✅ Handle both client and server-side validation errors
5. ✅ Show loading states and disable submit during submission
6. ✅ Reset form after successful submission
7. ✅ Use TanStack Query mutations for better state management

**Benefits:**

- **Type Safety**: Compile-time validation with TypeScript
- **Consistency**: Shared schemas ensure validation consistency
- **Performance**: Optimized form performance with minimal re-renders
- **User Experience**: Immediate feedback and clear error messages
- **Maintainability**: Centralized validation logic and reusable components

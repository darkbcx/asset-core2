---
title: Layered Architecture Specification
description: Next.js App Router project architecture with clear separation of concerns
alwaysApply: true
---

# Layered Architecture Specification

## Overview

AssetCore implements a layered architecture that organizes a Next.js App Router project into clear, decoupled layers. This design allows the frontend and backend logic to evolve independently while supporting future migration of backend logic to other frameworks (e.g., Hono or Express) with minimal refactoring.

### Key Benefits

- **Separation of Concerns**: Clear boundaries between UI, API, business logic, and data access
- **Framework Independence**: Backend logic is decoupled from Next.js runtime
- **Type Safety**: Shared TypeScript types across all layers
- **Migration Ready**: Easy transition to external backend services
- **Developer Experience**: Clean, maintainable codebase structure

## Project Structure

### Folder Organization

```
src/
├── app/                     # Frontend (Next.js App Router)
│   ├── api/                 # API controllers (Next.js route handlers)
│   │   └── users/
│   │       └── route.ts
│   ├── users/
│   │   └── page.tsx         # Example UI page
│   └── layout.tsx
│
├── backend/                 # Business logic & repositories
│   ├── users.ts
│   └── jobs.ts
│
├── lib/                     # Shared utilities
│   ├── db.ts                # Database connector (mysql2)
│   ├── api-client/          # Frontend SDK (fetch wrapper)
│   │   ├── index.ts         # Export all clients
│   │   ├── assets.ts        # Asset-related API calls
│   │   ├── components.ts    # Component-related API calls
│   │   ├── maintenance.ts   # Maintenance-related API calls
│   │   ├── users.ts         # User-related API calls
│   │   └── companies.ts     # Company-related API calls
│   └── validators/           # Zod validation schemas
│       ├── index.ts         # Export all validators
│       ├── assets.ts        # Asset validation schemas
│       ├── components.ts    # Component validation schemas
│       ├── maintenance.ts   # Maintenance validation schemas
│       ├── users.ts         # User validation schemas
│       └── companies.ts     # Company validation schemas
│
└── types/                   # Shared TypeScript types
    ├── user.ts
    └── job.ts
```

## Layer Responsibilities

### UI / Presentation Layer
- **Folder**: `src/app/`
- **Purpose**: React components, pages, and hooks. Renders UI and calls the API client.
- **Depends On**: `api-client`
- **Migration**: Unchanged

### API Controllers Layer
- **Folder**: `src/app/api/.../route.ts`
- **Purpose**: Next.js route handlers that map HTTP requests → backend calls.
- **Depends On**: `src/backend/`
- **Migration**: Replaced by new backend routes

### Backend (Business Logic) Layer
- **Folder**: `src/backend/*.ts`
- **Purpose**: Core logic (repositories, services, data access). Stateless and framework-agnostic.
- **Depends On**: `lib/db.ts`, `lib/validators/`
- **Migration**: Moved directly to backend service

### Data Access Layer
- **Folder**: `src/lib/db.ts`
- **Purpose**: Handles DB connections (mysql2).
- **Depends On**: None
- **Migration**: Move with backend

### API Client (Frontend SDK) Layer
- **Folder**: `src/lib/api-client/*.ts`
- **Purpose**: Typed fetch wrapper for frontend. Encapsulates API URL logic.
- **Depends On**: None
- **Migration**: Update base URL only

### Types / Schemas Layer
- **Folder**: `src/types/`, `src/lib/validators/`
- **Purpose**: Shared type definitions and validation schemas.
- **Depends On**: All layers
- **Migration**: Move to `packages/shared`

### External Systems Layer
- **Folder**: N/A
- **Purpose**: Third-party integrations (Auth, Storage, etc.).
- **Depends On**: Backend
- **Migration**: Remain backend-side

## Request Flow Architecture

### Data Flow Pattern

```
[ React UI (app/users/page.tsx) ]
          │
          ▼
[ API Client (lib/apiClient.ts) ]
          │
          ▼
[ API Controller (app/api/users/route.ts) ]
          │
          ▼
[ Backend Logic (backend/users.ts) ]
          │
          ▼
[ Database / External Services (lib/db.ts) ]
```

### Example Implementation Flow

This demonstrates the complete data flow when a user requests information through the layered architecture:

| Layer          | File                               | Example Function                              |
| -------------- | ---------------------------------- | --------------------------------------------- |
| UI             | `/src/app/users/page.tsx`          | `apiClient.users.getUser("u1")`               |
| API Client     | `lib/api-client/users.ts`          | `fetch('/users/'+ userId)`                    |
| API Controller | `/src/app/api/users/[id]/route.ts` | Calls `getUserById()` from backend            |
| Backend        | `/src/backend/users.ts`            | Implements `getUserById()` and `createUser()` |
| Database       | `/src/lib/db.ts`                   | Uses mysql2 to query data                     |

#### Flow Description

1. **UI Layer**: React component calls the API client to fetch user data
2. **API Client**: Typed wrapper makes HTTP request to the API endpoint
3. **API Controller**: Next.js route handler receives request and delegates to backend
4. **Backend Layer**: Business logic processes the request and queries the database
5. **Database Layer**: mysql2 connection executes the SQL query and returns results

This flow ensures clean separation of concerns while maintaining type safety across all layers.

## Design Principles

### Core Architectural Principles

1. **Thin Controllers**

   - API routes (`/app/api`) should only handle request/response logic
   - No business logic in route handlers
   - Focus on HTTP concerns (validation, serialization, error handling)

2. **Business Logic Isolation**

   - All backend logic lives in `/backend`, decoupled from Next.js runtime
   - Framework-agnostic business logic
   - Stateless service functions

3. **Single Source of Truth for Types**

   - All DTOs and schemas defined in `/types` or `/lib/validators/`
   - Shared type definitions across frontend and backend
   - Zod schemas for runtime validation (organized by resource)
   - Type inference from Zod schemas ensures consistency

4. **Future Portability**

   - `/backend` and `/types` can be moved to another platform with no rewrite
   - No Next.js-specific dependencies in business logic
   - Clean separation enables microservice migration

5. **Minimal Frontend Coupling**
   - Frontend interacts only via `apiClient`, not raw fetch or database
   - No direct database access from UI components
   - Centralized API communication

## Migration Strategy

### Future Backend Migration

When migrating backend logic to external services:

```
apps/
  frontend/   ← Next.js app
  backend/    ← Hono / Express app
packages/
  shared/     ← Former /backend and /types code
```

#### Migration Steps

1. **Move Business Logic**

   - Move `/src/backend` → `packages/shared/backend`
   - Move `/src/types` → `packages/shared/types`
   - Move `/src/lib/validators/` → `packages/shared/validators`
   - Update import paths

2. **Update API Client**

   - Update `api-client` base URL in each client file (`NEXT_PUBLIC_API_URL`)
   - Modify authentication handling if needed
   - Update error handling for external service
   - API client structure remains the same (just base URL changes)

3. **Frontend Compatibility**
   - Frontend remains fully functional
   - No changes required to React components
   - API client abstracts external service details

## Implementation Guidelines

### Backend Layer (`src/backend/`)

- **Pure Functions**: Business logic functions should be pure and testable
- **No Framework Dependencies**: Avoid Next.js-specific imports
- **Database Abstraction**: Use database connection from `lib/db.ts`
- **Error Handling**: Consistent error handling and validation

### API Controller Layer (`src/app/api/`)

- **Request Validation**: Validate incoming requests using Zod schemas
- **Response Serialization**: Format responses consistently
- **Error Handling**: Handle HTTP errors and return appropriate status codes
- **Authentication**: Validate JWT tokens and user permissions

### Frontend Layer (`src/app/`)

- **Component Logic**: Focus on UI logic and user interactions
- **API Communication**: Use `api-client` module for all backend communication
- **State Management**: Use React hooks and context for local state
- **Error Boundaries**: Implement error boundaries for graceful error handling

### API Client Layer (`src/lib/api-client/`)

- **Organization**: Grouped by resource/feature (assets, components, users, etc.)
- **Type Safety**: Full TypeScript types for all API calls
- **Error Handling**: Centralized error handling for API requests
- **Authentication**: Automatic token injection for authenticated requests
- **Base Configuration**: Shared fetch configuration and base URL

### Validators Layer (`src/lib/validators/`)

- **Organization**: Grouped by resource/feature (assets, components, users, etc.)
- **Zod Schemas**: Type-safe validation schemas for all entities
- **Reusability**: Shared between frontend forms and backend API validation
- **Type Inference**: TypeScript types automatically inferred from schemas
- **Centralized Export**: All validators exported via index.ts

### Shared Layer (`src/lib/` & `src/types/`)

- **Database Connection**: Centralized database connection management
- **API Client**: Typed wrapper for HTTP requests (organized by resource)
- **Validation Schemas**: Zod schemas for request/response validation
- **Type Definitions**: Shared TypeScript interfaces and types

## Benefits

This layered architecture provides:

- **Clear separation of concerns** between UI, API, and business logic
- **Type-safe contracts** between frontend and backend layers
- **Easy future migration** to external backend services
- **Clean developer ergonomics** for fullstack TypeScript development
- **Maintainable codebase** with well-defined boundaries
- **Testable architecture** with isolated, pure functions

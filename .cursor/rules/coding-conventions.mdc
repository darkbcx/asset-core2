---
title: Coding Conventions
description: A comprehensive guide to coding standards, project structure, and development patterns for maintaining consistent, secure, and maintainable code across the project.
alwaysApply: true
---

# Coding Conventions

## Overview

AssetCore follows comprehensive coding standards to ensure consistent, secure, and maintainable code across the entire project. These conventions cover function design, naming patterns, and backend development practices to maintain high code quality and developer productivity.

### Key Principles

- **Consistency**: Uniform coding patterns across all files and components
- **Type Safety**: Full TypeScript integration with proper type definitions
- **Security**: Secure coding practices and input validation
- **Maintainability**: Clean, readable code with clear structure
- **Performance**: Optimized patterns for backend and database operations

## Core Development Patterns

### API Route Layer Separation

**API routes MUST NOT execute direct database queries.**

API routes are part of the presentation layer and should only handle HTTP concerns:
- Request validation
- Response formatting
- Error handling
- HTTP status codes

**All database operations MUST be delegated to backend repository functions.**

```typescript
// ✅ CORRECT: API route delegates to backend functions
import { NextRequest, NextResponse } from 'next/server';
import { getUserById } from '@/backend/user';

export async function GET(request: NextRequest) {
  const userId = request.params.id;
  const result = await getUserById(userId);
  
  if (!result.success) {
    return NextResponse.json(
      { error: result.error },
      { status: 404 }
    );
  }
  
  return NextResponse.json({ user: result.result });
}

// ❌ WRONG: Direct database query in API route
import { db } from '@/lib/db';

export async function GET(request: NextRequest) {
  const [users] = await db.execute('SELECT * FROM users WHERE id = ?', [userId]);
  return NextResponse.json({ user: users[0] });
}
```

**When creating new functionality:**
1. If a backend function exists, use it
2. If no backend function exists, create one in the appropriate repository
3. Never add database queries directly in API routes

### Backend Response Pattern

**All backend functions MUST return a standardized response object:**

```typescript
// Standard response interface (defined in src/backend/types.ts)
interface BackendResponse<T> {
  success: boolean;
  result?: T;
  error?: string;
}
```

#### Implementation Rules

**1. Success Responses:**
- Set `success: true`
- Include data in `result` field
- Omit `error` field

**2. Error Responses:**
- Set `success: false`
- Include error message in `error` field
- Omit `result` field

**3. Example Implementation:**

```typescript
// ✅ CORRECT: Standard BackendResponse pattern
import type { BackendResponse } from '@/backend/types';

export async function getUserById(userId: string): Promise<BackendResponse<User>> {
  try {
    const user = await db.queryOne<User>(query, [userId]);
    
    if (!user) {
      return {
        success: false,
        error: 'User not found',
      };
    }
    
    return {
      success: true,
      result: user,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Failed to get user',
    };
  }
}

// ✅ CORRECT: Calling backend functions
const userResult = await getUserById(userId);
if (!userResult.success || !userResult.result) {
  return {
    success: false,
    error: userResult.error || 'User not found',
  };
}
const user = userResult.result; // Extract from result

// ❌ WRONG: Returning direct values or throwing errors
export async function getUserById(userId: string): Promise<User | null> {
  const user = await db.queryOne<User>(query, [userId]);
  return user; // Don't return direct values
}

export async function getUserById(userId: string): Promise<User> {
  const user = await db.queryOne<User>(query, [userId]);
  if (!user) {
    throw new Error('User not found'); // Don't throw errors
  }
  return user;
}
```

#### Benefits

- **Consistent Error Handling**: All functions follow the same pattern
- **Type Safety**: Clear typing for success and error cases
- **Easy Testing**: Predictable response structure
- **Better UX**: Consistent error messages across the application
- **No Exception Propagation**: Eliminates need for try-catch in every caller

#### Function Organization Rules

**Export standalone functions when:**
- Return `BackendResponse<T>` pattern
- Are core business logic functions
- Have important roles in the module

**Export grouped utility objects when:**
- Small, pure utility functions
- Don't return `BackendResponse`
- Used for transformations or parsing
- Multiple related small helpers

```typescript
// ✅ CORRECT: Standalone function (returns BackendResponse)
export async function getUserById(userId: string): Promise<BackendResponse<User>> {
  // ... implementation
}

// ✅ CORRECT: Standalone utility function (simple parsing)
export function extractTokenFromHeader(authHeader: string | null): string | null {
  if (!authHeader) return null;
  const parts = authHeader.split(' ');
  return parts.length === 2 && parts[0] === 'Bearer' ? parts[1] : null;
}

// ✅ CORRECT: Grouped utilities (multiple small helpers)
export const tokenUtils = {
  extractFromHeader(authHeader: string | null): string | null { /* ... */ },
  validateFormat(token: string): boolean { /* ... */ },
  decodeWithoutVerify(token: string): Record<string, unknown> { /* ... */ },
};

// ❌ WRONG: Grouping core business logic
export const authActions = {
  async login(credentials: Login): Promise<BackendResponse<AuthResponse>> { /* ... */ },
  async refreshToken(token: string): Promise<BackendResponse<RefreshTokenResponse>> { /* ... */ },
};
```

### Pure Functions

AssetCore emphasizes the use of pure functions for business logic and data operations.

```typescript
// ✅ CORRECT: Pure functions
export async function findAssetById(context: CompanyContext, id: string): Promise<Asset | null> {
  return queryOne('SELECT * FROM assets WHERE id = ? AND company_id = ?', [id, context.companyId]);
}

// ❌ AVOID: Classes (unless needed for instanceof)
export class AssetRepository { }
```

### Schema Validation & Type Inference

AssetCore uses Zod schemas as the single source of truth for types and validation.

```typescript
// ✅ CORRECT: Define Zod schemas in /src/lib/validators/ folder

// src/lib/validators/user.ts
import { z } from 'zod';

export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  first_name: z.string().min(1).max(100),
  last_name: z.string().max(100).optional(),
  is_active: z.boolean(),
  created_at: z.date(),
  updated_at: z.date(),
});

// Create schema with same fields but all optional
export const createUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  first_name: z.string().min(1).max(100),
  last_name: z.string().max(100).optional(),
});

// ✅ CORRECT: Use z.infer to derive types from schemas
export type User = z.infer<typeof userSchema>;
export type CreateUser = z.infer<typeof createUserSchema>;

// ✅ CORRECT: Add extended types/interfaces in the same file
export interface UserWithCompanies extends User {
  companies?: UserCompany[];
}

// ✅ CORRECT: Export types in validator index
// src/lib/validators/index.ts
export * from './user';

// ❌ WRONG: Don't create separate type files
// src/types/user.ts - DON'T do this
export interface User { ... }

// ❌ WRONG: Don't manually define types when you can infer them
type User = {
  id: string;
  email: string;
  // ...
}

// ✅ CORRECT: Use shared schemas in backend logic
import { createUserSchema } from '@/lib/validators/user';
import type { CreateUser } from '@/lib/validators/user';

export async function createUser(userData: CreateUser) {
  const validated = createUserSchema.parse(userData);
  // ... implementation
}
```

## Naming Conventions

### Variables & Functions

```typescript
// ✅ CORRECT: Descriptive, camelCase

// Boolean variables: use 'is', 'has', 'should', 'can'
const isAuthenticated = true;
const hasPermission = false;
const shouldRefetch = true;
const canEdit = user.role === 'admin';
const isSysAdmin = user.systemRole === 'System Administrators';  // ⭐ System Administrators check

// Arrays: plural nouns
const assets = await getAssets();
const tickets = await getTickets();
const maintenanceRecords = await getMaintenanceRecords();
const companies = await getAllCompanies();          // ⭐ System-wide data

// Single objects: singular nouns
const asset = await getAssetById(id);
const ticket = await getTicketById(id);
const user = await getUserById(id);

// Functions: verb + noun
async function getAssets() { }
async function createAsset() { }
async function updateAssetStatus() { }
async function deleteAsset() { }
async function getAllCompanies() { }                // ⭐ System Administrators function
async function getUserSystemRole() { }              // ⭐ System Administrators function

// Event handlers: 'handle' or 'on' prefix
function handleSubmit() { }
function handleAssetClick() { }
function onTicketCreate() { }
function onMaintenanceComplete() { }

// ❌ WRONG: Unclear or inconsistent
const a = await getAssets();              // Too short
const AssetsList = [];                    // Should be camelCase
const authenticated = true;               // Use isAuthenticated
const asset = await getAssets();          // Singular/plural mismatch
function getData() { }                    // Too generic
function click() { }                      // No context
```

### Constants

```typescript
// ✅ CORRECT: UPPER_SNAKE_CASE for true constants

// Configuration constants
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const API_BASE_URL = '/api';
const DEFAULT_PAGE_SIZE = 20;

// Enum-like objects
const ASSET_STATUS = {
  OPERATIONAL: 'operational',
  INACTIVE: 'inactive',
  MAINTENANCE: 'maintenance',
} as const;

const USER_ROLES = {
  System Administrators: 'System Administrators',         // ⭐ System-wide role
  ADMIN: 'admin',
  MANAGER: 'manager',
  TECHNICIAN: 'technician',
  FIELD_OPS: 'field_ops',
} as const;

// ❌ WRONG: Regular variables as constants
const maxFileSize = 5242880;              // Should be UPPER_SNAKE_CASE
const AssetStatus = { ... };              // Should be UPPER_SNAKE_CASE
```

### Types & Interfaces

```typescript
// ✅ CORRECT: PascalCase, descriptive names

// Interfaces: noun, describing the shape
interface Asset {
  id: string;
  assetCode: string;
  type: string;
}

interface User {
  id: string;
  email: string;
  name: string;
  systemRole?: string | null;   // ⭐ System Administrators role
}

// Types: noun or adjective + noun
type AssetStatus = 'operational' | 'inactive' | 'maintenance';
type UserRole = 'System Administrators' | 'admin' | 'manager' | 'technician' | 'field_ops';  // ⭐ includes System Administrators
type MaintenanceType = 'immediate' | 'scheduled';

// Props: ComponentName + 'Props'
interface AssetCardProps {
  asset: Asset;
  onEdit?: () => void;
  onDelete?: () => void;
}

interface CompanyListProps {           // ⭐ Admin component props
  companies: Company[];
  onSelect?: (id: string) => void;
}

// Generic types: descriptive single letter or word
type Result<T, E = Error> = { success: true; data: T } | { success: false; error: E };
type Nullable<T> = T | null;
type AsyncFn<TArgs extends any[], TReturn> = (...args: TArgs) => Promise<TReturn>;

// ❌ WRONG: Unclear or inconsistent
interface asset { }                       // Should be PascalCase
interface IAsset { }                      // No 'I' prefix (not C#)
type Props { }                            // Too generic
interface AssetCardProperties { }        // Use 'Props' suffix
type T = 'operational' | 'inactive';      // Use descriptive name
```

## Summary

### Key Principles

- **Consistency**: Uniform coding patterns across all files and components
- **Type Safety**: Full TypeScript integration with proper type definitions
- **Security**: Secure coding practices and input validation
- **Maintainability**: Clean, readable code with clear structure
- **Performance**: Optimized patterns for backend and database operations
- **Standardized Responses**: All backend functions return `BackendResponse<T>` for consistent error handling

### Core Patterns

1. **Layer Separation**: API routes delegate to backend functions; never execute direct database queries
2. **BackendResponse Pattern**: All backend functions return `{ success: boolean; result?: T; error?: string }`
3. **Function Organization**: Core business logic exports as standalone functions; small utilities can be grouped
4. **Pure Functions**: Use pure functions for business logic, avoid classes unless needed
5. **Schema Validation**: Use Zod schemas as single source of truth for types and validation
6. **Naming Conventions**: Follow consistent naming patterns (camelCase for variables/functions, PascalCase for types)
7. **Error Handling**: Return error objects instead of throwing exceptions

### Benefits

- **Consistency**: Uniform patterns across all files and components
- **Type Safety**: Full TypeScript integration with proper type definitions
- **Security**: Secure coding practices and input validation
- **Maintainability**: Clean, readable code with clear structure
- **Performance**: Optimized patterns for backend and database operations
- **Predictable Error Handling**: Standardized response pattern eliminates exception propagation

---
title: API Design Standards
description: RESTful API design patterns and standards for AssetCore platform
alwaysApply: true
---

# API Design Standards

## Overview

AssetCore follows RESTful API design principles to provide a consistent, scalable, and maintainable interface for client applications. The API is designed with multi-tenancy in mind, ensuring proper data isolation and security across different organizations.

## Core API Standards

### Base Configuration

- **Base URL**: `https://api.assetcore.com/v1`
- **Protocol**: HTTPS only for all communications
- **API Versioning**: URL-based versioning (`/v1`, `/v2`, etc.)
- **Content Type**: `application/json` for all requests and responses
- **Character Encoding**: UTF-8 for all text content

### Authentication & Authorization

- **Authentication Method**: Bearer token in Authorization header
- **Header Format**: `Authorization: Bearer <jwt_token>`
- **Token Validation**: All protected endpoints validate JWT tokens
- **Permission Model**: Role-based access control (RBAC)
- **Multi-tenancy**: Company-scoped data access enforcement
- **Stateless Design**: API routes do not read or write cookies; tokens managed client-side

### Layer Separation & Controller Rules

**API routes MUST NOT access the database directly. Always delegate to backend repository/service functions.**

- **Thin Controllers**: API handlers focus only on HTTP concerns (validation, serialization, status codes)
- **No DB in Routes**: Never import `db` in `app/api/.../route.ts`
- **Delegate to Backend**: Call functions in `src/backend/*.ts` for all data access and business logic
- **Stateless Auth**: Read tokens from `Authorization: Bearer <token>` header; do not read/write cookies in API routes

```ts
// ✅ CORRECT: API route delegates to backend repository
import { NextRequest, NextResponse } from 'next/server';
import { listUsersPaginated } from '@/backend/user';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const limit = Number(searchParams.get('limit') || 50);
  const cursor = searchParams.get('cursor');
  const result = await listUsersPaginated({ limit, cursor: cursor || undefined });
  if (!result.success || !result.result) {
    return NextResponse.json({ error: result.error }, { status: 500 });
  }
  return NextResponse.json({ data: result.result.users, pagination: result.result.pagination });
}

// ❌ WRONG: Direct database access in API route
import { db } from '@/lib/db';
export async function GET() {
  const [rows] = await db.execute('SELECT * FROM users'); // ❌ Don't do this
  return NextResponse.json(rows);
}
```

### Request/Response Standards

#### Request Headers
```
Authorization: Bearer <jwt_token>
Content-Type: application/json
Accept: application/json
X-Request-ID: <unique_request_id>  # Optional for tracking
```

#### Response Headers
```
Content-Type: application/json
X-Request-ID: <unique_request_id>
X-Rate-Limit-Remaining: <number>
X-Rate-Limit-Reset: <timestamp>
```

### Error Handling

#### Standard Error Response Format
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": {
      "field": "email",
      "reason": "Invalid email format"
    },
    "request_id": "req_123456789"
  }
}
```

#### HTTP Status Codes
- **200**: Success
- **201**: Created
- **400**: Bad Request (validation errors)
- **401**: Unauthorized (invalid/missing token)
- **403**: Forbidden (insufficient permissions)
- **404**: Not Found
- **409**: Conflict (duplicate resource)
- **422**: Unprocessable Entity (business logic errors)
- **429**: Too Many Requests (rate limit exceeded)
- **500**: Internal Server Error

### Pagination

#### Cursor-Based Pagination
```json
{
  "data": [...],
  "pagination": {
    "cursor": "eyJpZCI6MTIzfQ==",
    "limit": 50,
    "has_more": true
  }
}
```

#### Query Parameters
- `limit`: Number of items per page (default: 50, max: 100)
- `cursor`: Base64-encoded cursor for pagination
- `sort`: Field to sort by (e.g., `created_at`, `-name` for descending)

Note: `total_count` is optional to avoid expensive full-count queries. Provide it only when requested (e.g., `?includeTotalCount=true`) or expose a separate lightweight endpoint for counts.

### Rate Limiting

- **Library**: Use `rate-limiter-flexible` for API rate limiting
- **Default Policy**: 1000 requests/hour per user (or IP if unauthenticated)
- **Headers**: Include `X-Rate-Limit-Remaining` and `X-Rate-Limit-Reset` in responses
- **Storage**: In-memory `RateLimiterMemory` by default; optionally Redis in production
- **Scopes**: Prefer per-user (JWT `sub`) fallback to per-IP (`x-forwarded-for` or `request.ip`)

```ts
// Example usage in API route (simplified)
import { NextRequest, NextResponse } from 'next/server';
import { rateLimit } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  const key = request.headers.get('authorization') ? 'user' : 'ip';
  const id = key === 'user'
    ? (request.headers.get('authorization') || 'anon')
    : (request.headers.get('x-forwarded-for') || request.ip || 'anon');

  const limited = await rateLimit(id);
  if (!limited.ok) return limited.response;

  // ... handler
}
```

### Refresh Tokens Policy

- **Storage**: Refresh tokens are stored server-side in the database (`refresh_tokens` table) as SHA-256 hashes. Each token record includes `user_id`, `token_hash`, `expires_at`, `revoked` status, and `created_at` timestamp. Tokens are never stored in plaintext.
- **Database Schema**: The `refresh_tokens` table uses `CHAR(36)` for `id` and `user_id`, `VARCHAR(64)` for `token_hash` (unique), `TIMESTAMP` for `expires_at`, and `BOOLEAN` for `revoked`. Indexes on `user_id`, `token_hash`, `expires_at`, and `revoked` ensure efficient lookups.
- **Rotation**: On each successful refresh, the used refresh token is invalidated (marked as `revoked = TRUE`) and a new refresh token is issued and stored. The rotation is performed atomically within a database transaction to prevent race conditions.
- **Reuse Detection**: If a refresh token is presented that was already rotated or revoked, the system treats this as a suspected compromise and immediately revokes all active refresh tokens for that user. Reuse detection happens during token validation and rotation checks.
- **Revocation**: On logout or administrative action, specific tokens or all tokens for a user can be revoked by setting `revoked = TRUE` in the database. Revoked tokens cannot be used again and are filtered out during validation queries.
- **Expiration**: Enforce server-side expiration by checking `expires_at > CURRENT_TIMESTAMP` in validation queries. Expired tokens are automatically excluded from valid token queries regardless of client token content.
- **Transport**: Refresh tokens are returned in the response body; clients must store securely on the client side (prefer cookies over localStorage) and send only to the refresh endpoint.
- **Implementation**: Refresh token management functions (`storeRefreshToken`, `isRefreshTokenValid`, `rotateRefreshToken`, `revokeRefreshToken`, `revokeAllForUser`) are implemented in `@/backend/authentication.ts` using database queries with prepared statements for SQL injection prevention.

**Endpoints**:
- `POST /api/auth/refresh` – Validates token hash against database, detects reuse, rotates token atomically, and returns new access/refresh tokens
- `POST /api/auth/logout` – Optionally accepts the current refresh token and revokes it server-side via database update (client still clears local storage)
- `POST /api/auth/set-active-company` – Revokes all existing refresh tokens for the user and stores a new refresh token when switching company context

```ts
// Refresh flow (database-backed)
// 1) Verify refresh JWT signature and claims
// 2) Hash token (SHA-256) and check database for token_hash (exists, not expired, not revoked)
// 3) Use transaction to atomically rotate (invalidate old, store new) + detect reuse
// 4) Return new tokens
```

**Database Functions**:
- `storeRefreshToken(userId, token, expiresAt)` - Stores hashed token in database
- `isRefreshTokenValid(userId, token)` - Validates token hash exists, not revoked, not expired
- `rotateRefreshToken(userId, oldToken, newToken, newExpiresAt)` - Atomically rotates token with reuse detection
- `revokeRefreshToken(token)` - Revokes specific token by hash
- `revokeAllForUser(userId)` - Revokes all active tokens for a user

## API Endpoint Structure

### Multi-Tenant Resource Organization

All resources are organized under company scope to ensure proper data isolation:

```
/companies                           # Company management
├── /companies/{company_id}/users    # User management within company
├── /companies/{company_id}/assets   # Asset management
├── /companies/{company_id}/components # Component management
├── /companies/{company_id}/maintenance # Maintenance records
├── /companies/{company_id}/locations # Location management
└── /companies/{company_id}/reports  # Analytics and reporting
```

### Resource Naming Conventions

- **Plural Nouns**: Use plural forms for resource collections (`/assets`, `/users`)
- **Hyphenated**: Use hyphens for multi-word resources (`maintenance-records`)
- **Consistent**: Maintain consistent naming across all endpoints
- **Descriptive**: Use clear, descriptive names that indicate resource purpose

### HTTP Methods Usage

- **GET**: Retrieve resources (single or collection)
- **POST**: Create new resources
- **PUT**: Update entire resources (replace)
- **PATCH**: Partial updates to resources
- **DELETE**: Remove resources

### Query Parameters

#### Filtering
- `filter[field]=value`: Filter by specific field values
- `filter[field][gte]=value`: Greater than or equal filtering
- `filter[field][lte]=value`: Less than or equal filtering
- `filter[field][in]=value1,value2`: Multiple value filtering

#### Searching
- `search=term`: Full-text search across searchable fields
- `search[field]=term`: Field-specific search

#### Sorting
- `sort=field`: Sort ascending by field
- `sort=-field`: Sort descending by field
- `sort=field1,field2`: Multiple field sorting

## Security Considerations

### Stateless API Design

**API routes MUST be stateless and MUST NOT read or write cookies.**

**CRITICAL BOUNDARY: API Routes vs App Routes**

- **API Routes** (`app/api/**/route.ts`): MUST NOT access cookies at all. Authentication via JWT in `Authorization` header only.
- **App Routes** (`app/**/page.tsx`, Server Components): May use cookies for client state management (e.g., active company selection), but should not rely on cookies for authentication (use JWT instead).

**Enforcement:**

```typescript
// ✅ CORRECT: API route - no cookie access
import { NextRequest, NextResponse } from 'next/server';
// ❌ DO NOT import { cookies } from 'next/headers' in API routes

export async function GET(request: NextRequest) {
  // Get token from Authorization header only
  const authHeader = request.headers.get('authorization');
  const token = authHeader?.replace('Bearer ', '');
  // ... process request
}

// ❌ WRONG: API route accessing cookies
import { cookies } from 'next/headers'; // ❌ DON'T import this in API routes

export async function GET() {
  const cookieStore = await cookies(); // ❌ DON'T access cookies in API routes
  const token = cookieStore.get('token')?.value; // ❌ DON'T
}

// ✅ CORRECT: App route (page) - cookies allowed for client state
import { cookies } from 'next/headers'; // ✅ OK in app routes

export default async function DashboardPage() {
  const cookieStore = await cookies();
  const activeCompanyId = cookieStore.get('active_company_id')?.value; // ✅ OK for client state
  // But authentication still via JWT in headers when calling APIs
}
```

**Key Principles:**

- **No Cookie Management**: API routes do not read or write cookies (no exceptions)
- **Client-Managed Tokens**: Tokens are returned in response bodies for client to manage
- **Authorization Header**: Tokens sent via `Authorization: Bearer <token>` header
- **Company Context in JWT**: Active company context is carried in the JWT claim `active_company_id`
- **Stateless Requests**: Each request is independent and self-contained
- **Horizontal Scaling**: Stateless design enables easy horizontal scaling

```typescript
// ✅ CORRECT: Token in Authorization header
const response = await fetch('/api/assets', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
  },
});

// ✅ CORRECT: Return token in response body
return NextResponse.json({
  success: true,
  token: result.token,
  refreshToken: result.refreshToken,
});

// ❌ WRONG: Reading/writing cookies in API routes
const cookieStore = await cookies();
const token = cookieStore.get('token')?.value; // ❌ DON'T
response.cookies.set('token', token); // ❌ DON'T
```

### Data Protection
- **Input Validation**: Comprehensive validation of all input data using Zod schemas
- **SQL Injection Prevention**: Prepared statements with mysql2 parameterized queries
- **XSS Protection**: Output encoding and content security policies
- **CSRF Protection**: CSRF tokens for state-changing operations

### SQL Injection Prevention Strategies

#### Prepared Statements with mysql2
```javascript
// ✅ CORRECT: Use parameterized queries
const query = 'SELECT * FROM assets WHERE company_id = ? AND status = ?';
const [rows] = await connection.execute(query, [companyId, status]);

// ✅ CORRECT: Multiple parameters
const query = 'INSERT INTO assets (company_id, name, type) VALUES (?, ?, ?)';
const [result] = await connection.execute(query, [companyId, name, type]);
```

#### Input Sanitization
```javascript
// ✅ CORRECT: Validate and sanitize input
const validatedData = assetSchema.parse(requestBody);
const query = 'UPDATE assets SET name = ?, type = ? WHERE id = ? AND company_id = ?';
await connection.execute(query, [
  validatedData.name,
  validatedData.type,
  assetId,
  companyId
]);
```

#### Dynamic Query Building
```javascript
// ✅ CORRECT: Safe dynamic query building
const conditions = [];
const params = [];

if (filters.status) {
  conditions.push('status = ?');
  params.push(filters.status);
}

if (filters.type) {
  conditions.push('type = ?');
  params.push(filters.type);
}

const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
const query = `SELECT * FROM assets ${whereClause} ORDER BY created_at DESC`;
const [rows] = await connection.execute(query, params);
```

#### Common Anti-Patterns to Avoid
```javascript
// ❌ WRONG: String concatenation (vulnerable to SQL injection)
const query = `SELECT * FROM assets WHERE name = '${name}'`;

// ❌ WRONG: Template literals with user input
const query = `SELECT * FROM assets WHERE company_id = ${companyId}`;

// ❌ WRONG: Using query() instead of execute()
const query = 'SELECT * FROM assets WHERE id = ?';
const [rows] = await connection.query(query, [id]); // Use execute() instead
```

### Multi-Tenancy Security
- **Data Isolation**: Strict company-based data separation
- **Access Control**: Company-scoped permissions enforcement
- **Audit Logging**: Comprehensive logging of all API access
- **Resource Validation**: Verify resource ownership before operations

#### Company Administrator User Management Restrictions

**Company Administrators can only manage users assigned to their active company.**

**Enforcement Rules:**

1. **Active Company Scope**: Company Administrators can only manage users that have an active association with their **active company** (the company context in their current session via `active_company_id` in JWT token)
2. **Multi-Company Administrators**: If a Company Administrator is assigned to multiple companies, they can only manage users from their currently active company. They must switch to another company context (via `/api/auth/set-active-company`) to manage users in that company
3. **User Creation**: Company Administrators can create new users and the user is **automatically assigned** to the Company Administrator's active company. The newly created user will have:
   - `user_type = 'tenant'` (cannot create system administrators)
   - An automatic user-company association created linking them to the active company
   - A role assigned by the Company Administrator (defaults to a role specified during creation)
4. **User Assignment**: Company Administrators can assign existing users to their active company if:
   - The user is not already assigned to the active company (check `user_companies` table)
   - The user is a tenant user (`user_type = 'tenant'`), not a system administrator
   - The user may be assigned to other companies or no companies yet
   - Creates a new user-company association with the specified role
5. **Tenant Users Only**: Company Administrators can only manage tenant users (`user_type = 'tenant'`), not system administrators (`user_type = 'system_admin'`)
6. **Company Isolation**: Company Administrators cannot manage users from other companies, even if:
   - The Company Administrator has access to multiple companies
   - The target user has access to multiple companies
   - The user belongs to a different company than the active one
   - **Exception**: Can assign existing users from other companies to their active company (creates new association)
7. **Verification Required**: All user management operations must verify that:
   - The target user is assigned to the Company Administrator's **active company** (via `user_companies` table using `active_company_id` from JWT)
   - The target user is a tenant user (`user_type = 'tenant'`)
   - The user-company association is active (`is_active = true`)

**Implementation Pattern:**

```typescript
// ✅ CORRECT: Company Administrator user management with validation
import { NextRequest, NextResponse } from 'next/server';
import { extractTokenFromHeader, createAuthContext } from '@/backend/authentication';
import { getUsersByCompany, updateUser, createUser, getUserById } from '@/backend/user';
import { userHasCompanyAccess, createUserCompany } from '@/backend/user';

export async function GET(request: NextRequest) {
  // Extract and validate authentication
  const authHeader = request.headers.get('authorization');
  const token = extractTokenFromHeader(authHeader);
  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const ctx = await createAuthContext(token);
  if (!ctx.success || !ctx.result) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = ctx.result.user;
  const companyId = ctx.result.active_company_id;

  // Verify user is a Company Administrator with users:* permissions
  // (permission check logic here)

  // Only return users assigned to the Company Administrator's company
  const users = await getUsersByCompany(companyId);
  return NextResponse.json({ data: users });
}

export async function POST(request: NextRequest) {
  // Extract and validate authentication
  const authHeader = request.headers.get('authorization');
  const token = extractTokenFromHeader(authHeader);
  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const ctx = await createAuthContext(token);
  if (!ctx.success || !ctx.result) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = ctx.result.user;
  const companyId = ctx.result.active_company_id;

  // Verify user is a Company Administrator with users:create permissions
  // (permission check logic here)

  const body = await request.json();
  
  // Create user with user_type = 'tenant'
  // This ensures Company Administrators cannot create system administrators
  const userData = {
    ...body,
    user_type: 'tenant', // Force tenant user type
    system_role: null,   // Tenant users have no system_role
  };

  const newUser = await createUser(userData, body.password_hash);
  
  // Automatically create user-company association for active company
  const userCompanyData = {
    user_id: newUser.id,
    company_id: companyId, // Use active company from JWT
    role: body.role || 'maintenance_technician', // Default role if not specified
    is_active: true,
    is_primary: true, // Make this the primary company for the new user
  };

  await createUserCompany(userCompanyData);

  return NextResponse.json({ data: newUser }, { status: 201 });
}

export async function POST(request: NextRequest, { params }: { params: { userId: string } }) {
  // Assign existing user to active company
  // Extract and validate authentication
  const authHeader = request.headers.get('authorization');
  const token = extractTokenFromHeader(authHeader);
  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const ctx = await createAuthContext(token);
  if (!ctx.success || !ctx.result) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = ctx.result.user;
  const companyId = ctx.result.active_company_id;
  const targetUserId = params.userId;

  // Verify user is a Company Administrator with users:create permissions
  // (permission check logic here)

  // Verify target user exists and is a tenant user
  const targetUserResult = await getUserById(targetUserId);
  if (!targetUserResult.success || !targetUserResult.result) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  if (targetUserResult.result.user_type !== 'tenant') {
    return NextResponse.json(
      { error: 'Cannot assign system administrators' },
      { status: 403 }
    );
  }

  // Check if user is already assigned to this company
  const alreadyAssigned = await userHasCompanyAccess(targetUserId, companyId);
  if (alreadyAssigned) {
    return NextResponse.json(
      { error: 'User is already assigned to this company' },
      { status: 409 }
    );
  }

  const body = await request.json();
  
  // Create user-company association
  const userCompanyData = {
    user_id: targetUserId,
    company_id: companyId,
    role: body.role || 'maintenance_technician', // Default role if not specified
    is_active: true,
    is_primary: false, // Don't automatically set as primary (may have other companies)
  };

  const userCompany = await createUserCompany(userCompanyData);

  return NextResponse.json({ data: userCompany }, { status: 201 });
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  // Extract and validate authentication
  const authHeader = request.headers.get('authorization');
  const token = extractTokenFromHeader(authHeader);
  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const ctx = await createAuthContext(token);
  if (!ctx.success || !ctx.result) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const user = ctx.result.user;
  const companyId = ctx.result.active_company_id;
  const targetUserId = params.id;

  // Verify target user is assigned to the Company Administrator's company
  const hasAccess = await userHasCompanyAccess(targetUserId, companyId);
  if (!hasAccess) {
    return NextResponse.json(
      { error: 'User not found or access denied' },
      { status: 403 }
    );
  }

  // Verify target user is a tenant user (not a system administrator)
  const targetUser = await getUserById(targetUserId);
  if (!targetUser.success || !targetUser.result) {
    return NextResponse.json({ error: 'User not found' }, { status: 404 });
  }

  if (targetUser.result.user_type !== 'tenant') {
    return NextResponse.json(
      { error: 'Cannot manage system administrators' },
      { status: 403 }
    );
  }

  // Proceed with update operation
  const body = await request.json();
  const result = await updateUser(targetUserId, body);
  
  if (!result.success) {
    return NextResponse.json({ error: result.error }, { status: 400 });
  }

  return NextResponse.json({ data: result.result });
}
```

**Error Responses:**

- **403 Forbidden**: Returned when Company Administrator tries to manage:
  - Users not assigned to their **active company** (even if assigned to other companies they have access to)
  - System administrators (`user_type = 'system_admin'`)
  - Users from companies other than their currently active company
- **409 Conflict**: Returned when Company Administrator tries to assign a user who is already assigned to their active company

**Backend Function Requirements:**

All user management backend functions should:
- Accept `companyId` parameter for company-scoped queries
- Verify user-company association before operations
- Filter out system administrators from company-scoped user lists
- Use `getUsersByCompany(companyId)` for company-scoped user queries

**User Creation Requirements:**

When Company Administrators create users, the backend functions should:
- Automatically create the user with `user_type = 'tenant'` (never allow `user_type = 'system_admin'`)
- Automatically create a user-company association linking the new user to the Company Administrator's active company
- Set the created association as `is_active = true` and optionally `is_primary = true`
- Assign the role specified by the Company Administrator (or use a default role if not specified)

**User Assignment Requirements:**

When Company Administrators assign existing users to their active company, the backend functions should:
- Verify the user is not already assigned to the active company (check `user_companies` table)
- Verify the user is a tenant user (`user_type = 'tenant'`), not a system administrator
- Create a new user-company association linking the user to the Company Administrator's active company
- Set the created association as `is_active = true` and `is_primary = false` (user may have other companies)
- Assign the role specified by the Company Administrator (or use a default role if not specified)
- Return 409 Conflict if the user is already assigned to the active company

### Performance & Monitoring
- **Response Time Monitoring**: Track API response times
- **Error Rate Tracking**: Monitor and alert on error rates
- **Usage Analytics**: Track API usage patterns and trends
- **Health Checks**: Regular endpoint health monitoring

### Permission Checking (RBAC)

AssetCore standardizes permission checks across API routes and the web frontend using shared helpers.

System administrator terminology:
- `system_admin` is a user type (platform scope)
- `system_role` within `system_admin` is either `super_admin` (all permissions: `*:*`) or `support_admin` (read-focused support)

- Generic evaluator (shared): `src/lib/permissions.ts`
  - `checkPermissionsForContext(context, required, mode)` merges role-derived and explicit permissions and evaluates them.

- API routes (server): `src/lib/authz/api.ts`
  - `requireSystemAdmin(request)` validates JWT from `Authorization: Bearer <token>`, builds auth context, and enforces `system_admin`.
  - `requireSystemAdminWithPermissions(request, required, mode)` adds permission checks via the generic evaluator.
  - Usage in API routes: import from `@/lib/authz/api` and early-return with the provided `response`.

- Web/frontend (client/server components): `src/lib/authz/web.ts`
  - `hasUserPermissions(user, required, mode)` checks permissions for the current user context (e.g., from session or props).

Rules:
- API routes MUST use `@/lib/authz/api` guards (never read cookies; read the Authorization header only).
- Frontend MUST use `@/lib/authz/web` (no header parsing on the client).
- Roles map to permissions via `getRolePermissions(systemRole)`; `super_admin` maps to `*:*`.

Examples:
```ts
// API: require read permissions for users
import { requireSystemAdminWithPermissions } from '@/lib/authz/api';
export async function GET(request: NextRequest) {
  const auth = await requireSystemAdminWithPermissions(request, ['users:read', '*:read'], 'any');
  if (!auth.ok) return auth.response;
  // ...
}

// Web: check before showing a button
import { hasUserPermissions } from '@/lib/authz/web';
const canCreate = hasUserPermissions(user, 'users:create');
```

---
title: API Design Standards
description: RESTful API design patterns and standards for AssetCore platform
alwaysApply: true
---

# API Design Standards

## Overview

AssetCore follows RESTful API design principles to provide a consistent, scalable, and maintainable interface for client applications. The API is designed with multi-tenancy in mind, ensuring proper data isolation and security across different organizations.

## Core API Standards

### Base Configuration

- **Base URL**: `https://api.assetcore.com/v1`
- **Protocol**: HTTPS only for all communications
- **API Versioning**: URL-based versioning (`/v1`, `/v2`, etc.)
- **Content Type**: `application/json` for all requests and responses
- **Character Encoding**: UTF-8 for all text content

### Authentication & Authorization

- **Authentication Method**: Bearer token in Authorization header
- **Header Format**: `Authorization: Bearer <jwt_token>`
- **Token Validation**: All protected endpoints validate JWT tokens
- **Permission Model**: Role-based access control (RBAC)
- **Multi-tenancy**: Company-scoped data access enforcement
- **Stateless Design**: API routes do not read or write cookies; tokens managed client-side

### Layer Separation & Controller Rules

**API routes MUST NOT access the database directly. Always delegate to backend repository/service functions.**

- **Thin Controllers**: API handlers focus only on HTTP concerns (validation, serialization, status codes)
- **No DB in Routes**: Never import `db` in `app/api/.../route.ts`
- **Delegate to Backend**: Call functions in `src/backend/*.ts` for all data access and business logic
- **Stateless Auth**: Read tokens from `Authorization: Bearer <token>` header; do not read/write cookies in API routes

```ts
// ✅ CORRECT: API route delegates to backend repository
import { NextRequest, NextResponse } from 'next/server';
import { listUsersPaginated } from '@/backend/user';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const limit = Number(searchParams.get('limit') || 50);
  const cursor = searchParams.get('cursor');
  const result = await listUsersPaginated({ limit, cursor: cursor || undefined });
  if (!result.success || !result.result) {
    return NextResponse.json({ error: result.error }, { status: 500 });
  }
  return NextResponse.json({ data: result.result.users, pagination: result.result.pagination });
}

// ❌ WRONG: Direct database access in API route
import { db } from '@/lib/db';
export async function GET() {
  const [rows] = await db.execute('SELECT * FROM users'); // ❌ Don't do this
  return NextResponse.json(rows);
}
```

### Request/Response Standards

#### Request Headers
```
Authorization: Bearer <jwt_token>
Content-Type: application/json
Accept: application/json
X-Request-ID: <unique_request_id>  # Optional for tracking
```

#### Response Headers
```
Content-Type: application/json
X-Request-ID: <unique_request_id>
X-Rate-Limit-Remaining: <number>
X-Rate-Limit-Reset: <timestamp>
```

### Error Handling

#### Standard Error Response Format
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input data",
    "details": {
      "field": "email",
      "reason": "Invalid email format"
    },
    "request_id": "req_123456789"
  }
}
```

#### HTTP Status Codes
- **200**: Success
- **201**: Created
- **400**: Bad Request (validation errors)
- **401**: Unauthorized (invalid/missing token)
- **403**: Forbidden (insufficient permissions)
- **404**: Not Found
- **409**: Conflict (duplicate resource)
- **422**: Unprocessable Entity (business logic errors)
- **429**: Too Many Requests (rate limit exceeded)
- **500**: Internal Server Error

### Pagination

#### Cursor-Based Pagination
```json
{
  "data": [...],
  "pagination": {
    "cursor": "eyJpZCI6MTIzfQ==",
    "limit": 50,
    "has_more": true
  }
}
```

#### Query Parameters
- `limit`: Number of items per page (default: 50, max: 100)
- `cursor`: Base64-encoded cursor for pagination
- `sort`: Field to sort by (e.g., `created_at`, `-name` for descending)

Note: `total_count` is optional to avoid expensive full-count queries. Provide it only when requested (e.g., `?includeTotalCount=true`) or expose a separate lightweight endpoint for counts.

### Rate Limiting

- **Library**: Use `rate-limiter-flexible` for API rate limiting
- **Default Policy**: 1000 requests/hour per user (or IP if unauthenticated)
- **Headers**: Include `X-Rate-Limit-Remaining` and `X-Rate-Limit-Reset` in responses
- **Storage**: In-memory `RateLimiterMemory` by default; optionally Redis in production
- **Scopes**: Prefer per-user (JWT `sub`) fallback to per-IP (`x-forwarded-for` or `request.ip`)

```ts
// Example usage in API route (simplified)
import { NextRequest, NextResponse } from 'next/server';
import { rateLimit } from '@/lib/rate-limit';

export async function POST(request: NextRequest) {
  const key = request.headers.get('authorization') ? 'user' : 'ip';
  const id = key === 'user'
    ? (request.headers.get('authorization') || 'anon')
    : (request.headers.get('x-forwarded-for') || request.ip || 'anon');

  const limited = await rateLimit(id);
  if (!limited.ok) return limited.response;

  // ... handler
}
```

### Refresh Tokens Policy

- **Storage**: Refresh tokens are stored server-side in the database (`refresh_tokens` table) as SHA-256 hashes. Each token record includes `user_id`, `token_hash`, `expires_at`, `revoked` status, and `created_at` timestamp. Tokens are never stored in plaintext.
- **Database Schema**: The `refresh_tokens` table uses `CHAR(36)` for `id` and `user_id`, `VARCHAR(64)` for `token_hash` (unique), `TIMESTAMP` for `expires_at`, and `BOOLEAN` for `revoked`. Indexes on `user_id`, `token_hash`, `expires_at`, and `revoked` ensure efficient lookups.
- **Rotation**: On each successful refresh, the used refresh token is invalidated (marked as `revoked = TRUE`) and a new refresh token is issued and stored. The rotation is performed atomically within a database transaction to prevent race conditions.
- **Reuse Detection**: If a refresh token is presented that was already rotated or revoked, the system treats this as a suspected compromise and immediately revokes all active refresh tokens for that user. Reuse detection happens during token validation and rotation checks.
- **Revocation**: On logout or administrative action, specific tokens or all tokens for a user can be revoked by setting `revoked = TRUE` in the database. Revoked tokens cannot be used again and are filtered out during validation queries.
- **Expiration**: Enforce server-side expiration by checking `expires_at > CURRENT_TIMESTAMP` in validation queries. Expired tokens are automatically excluded from valid token queries regardless of client token content.
- **Transport**: Refresh tokens are returned in the response body; clients must store securely on the client side (prefer cookies over localStorage) and send only to the refresh endpoint.
- **Implementation**: Refresh token management functions (`storeRefreshToken`, `isRefreshTokenValid`, `rotateRefreshToken`, `revokeRefreshToken`, `revokeAllForUser`) are implemented in `@/backend/authentication.ts` using database queries with prepared statements for SQL injection prevention.

**Endpoints**:
- `POST /api/auth/refresh` – Validates token hash against database, detects reuse, rotates token atomically, and returns new access/refresh tokens
- `POST /api/auth/logout` – Optionally accepts the current refresh token and revokes it server-side via database update (client still clears local storage)
- `POST /api/auth/set-active-company` – Revokes all existing refresh tokens for the user and stores a new refresh token when switching company context

```ts
// Refresh flow (database-backed)
// 1) Verify refresh JWT signature and claims
// 2) Hash token (SHA-256) and check database for token_hash (exists, not expired, not revoked)
// 3) Use transaction to atomically rotate (invalidate old, store new) + detect reuse
// 4) Return new tokens
```

**Database Functions**:
- `storeRefreshToken(userId, token, expiresAt)` - Stores hashed token in database
- `isRefreshTokenValid(userId, token)` - Validates token hash exists, not revoked, not expired
- `rotateRefreshToken(userId, oldToken, newToken, newExpiresAt)` - Atomically rotates token with reuse detection
- `revokeRefreshToken(token)` - Revokes specific token by hash
- `revokeAllForUser(userId)` - Revokes all active tokens for a user

## API Endpoint Structure

### Multi-Tenant Resource Organization

All resources are organized under company scope to ensure proper data isolation:

```
/companies                           # Company management
├── /companies/{company_id}/users    # User management within company
├── /companies/{company_id}/assets   # Asset management
├── /companies/{company_id}/components # Component management
├── /companies/{company_id}/maintenance # Maintenance records
├── /companies/{company_id}/locations # Location management
└── /companies/{company_id}/reports  # Analytics and reporting
```

### Resource Naming Conventions

- **Plural Nouns**: Use plural forms for resource collections (`/assets`, `/users`)
- **Hyphenated**: Use hyphens for multi-word resources (`maintenance-records`)
- **Consistent**: Maintain consistent naming across all endpoints
- **Descriptive**: Use clear, descriptive names that indicate resource purpose

### HTTP Methods Usage

- **GET**: Retrieve resources (single or collection)
- **POST**: Create new resources
- **PUT**: Update entire resources (replace)
- **PATCH**: Partial updates to resources
- **DELETE**: Remove resources

### Query Parameters

#### Filtering
- `filter[field]=value`: Filter by specific field values
- `filter[field][gte]=value`: Greater than or equal filtering
- `filter[field][lte]=value`: Less than or equal filtering
- `filter[field][in]=value1,value2`: Multiple value filtering

#### Searching
- `search=term`: Full-text search across searchable fields
- `search[field]=term`: Field-specific search

#### Sorting
- `sort=field`: Sort ascending by field
- `sort=-field`: Sort descending by field
- `sort=field1,field2`: Multiple field sorting

## Security Considerations

### Stateless API Design

**API routes MUST be stateless and MUST NOT read or write cookies.**

**CRITICAL BOUNDARY: API Routes vs App Routes**

- **API Routes** (`app/api/**/route.ts`): MUST NOT access cookies at all. Authentication via JWT in `Authorization` header only.
- **App Routes** (`app/**/page.tsx`, Server Components): May use cookies for client state management (e.g., active company selection), but should not rely on cookies for authentication (use JWT instead).

**Enforcement:**

```typescript
// ✅ CORRECT: API route - no cookie access
import { NextRequest, NextResponse } from 'next/server';
// ❌ DO NOT import { cookies } from 'next/headers' in API routes

export async function GET(request: NextRequest) {
  // Get token from Authorization header only
  const authHeader = request.headers.get('authorization');
  const token = authHeader?.replace('Bearer ', '');
  // ... process request
}

// ❌ WRONG: API route accessing cookies
import { cookies } from 'next/headers'; // ❌ DON'T import this in API routes

export async function GET() {
  const cookieStore = await cookies(); // ❌ DON'T access cookies in API routes
  const token = cookieStore.get('token')?.value; // ❌ DON'T
}

// ✅ CORRECT: App route (page) - cookies allowed for client state
import { cookies } from 'next/headers'; // ✅ OK in app routes

export default async function DashboardPage() {
  const cookieStore = await cookies();
  const activeCompanyId = cookieStore.get('active_company_id')?.value; // ✅ OK for client state
  // But authentication still via JWT in headers when calling APIs
}
```

**Key Principles:**

- **No Cookie Management**: API routes do not read or write cookies (no exceptions)
- **Client-Managed Tokens**: Tokens are returned in response bodies for client to manage
- **Authorization Header**: Tokens sent via `Authorization: Bearer <token>` header
- **Company Context in JWT**: Active company context is carried in the JWT claim `active_company_id`
- **Stateless Requests**: Each request is independent and self-contained
- **Horizontal Scaling**: Stateless design enables easy horizontal scaling

```typescript
// ✅ CORRECT: Token in Authorization header
const response = await fetch('/api/assets', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
  },
});

// ✅ CORRECT: Return token in response body
return NextResponse.json({
  success: true,
  token: result.token,
  refreshToken: result.refreshToken,
});

// ❌ WRONG: Reading/writing cookies in API routes
const cookieStore = await cookies();
const token = cookieStore.get('token')?.value; // ❌ DON'T
response.cookies.set('token', token); // ❌ DON'T
```

### Data Protection
- **Input Validation**: Comprehensive validation of all input data using Zod schemas
- **SQL Injection Prevention**: Prepared statements with mysql2 parameterized queries
- **XSS Protection**: Output encoding and content security policies
- **CSRF Protection**: CSRF tokens for state-changing operations

### SQL Injection Prevention Strategies

#### Prepared Statements with mysql2
```javascript
// ✅ CORRECT: Use parameterized queries
const query = 'SELECT * FROM assets WHERE company_id = ? AND status = ?';
const [rows] = await connection.execute(query, [companyId, status]);

// ✅ CORRECT: Multiple parameters
const query = 'INSERT INTO assets (company_id, name, type) VALUES (?, ?, ?)';
const [result] = await connection.execute(query, [companyId, name, type]);
```

#### Input Sanitization
```javascript
// ✅ CORRECT: Validate and sanitize input
const validatedData = assetSchema.parse(requestBody);
const query = 'UPDATE assets SET name = ?, type = ? WHERE id = ? AND company_id = ?';
await connection.execute(query, [
  validatedData.name,
  validatedData.type,
  assetId,
  companyId
]);
```

#### Dynamic Query Building
```javascript
// ✅ CORRECT: Safe dynamic query building
const conditions = [];
const params = [];

if (filters.status) {
  conditions.push('status = ?');
  params.push(filters.status);
}

if (filters.type) {
  conditions.push('type = ?');
  params.push(filters.type);
}

const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
const query = `SELECT * FROM assets ${whereClause} ORDER BY created_at DESC`;
const [rows] = await connection.execute(query, params);
```

#### Common Anti-Patterns to Avoid
```javascript
// ❌ WRONG: String concatenation (vulnerable to SQL injection)
const query = `SELECT * FROM assets WHERE name = '${name}'`;

// ❌ WRONG: Template literals with user input
const query = `SELECT * FROM assets WHERE company_id = ${companyId}`;

// ❌ WRONG: Using query() instead of execute()
const query = 'SELECT * FROM assets WHERE id = ?';
const [rows] = await connection.query(query, [id]); // Use execute() instead
```

### Multi-Tenancy Security
- **Data Isolation**: Strict company-based data separation
- **Access Control**: Company-scoped permissions enforcement
- **Audit Logging**: Comprehensive logging of all API access
- **Resource Validation**: Verify resource ownership before operations

### Performance & Monitoring
- **Response Time Monitoring**: Track API response times
- **Error Rate Tracking**: Monitor and alert on error rates
- **Usage Analytics**: Track API usage patterns and trends
- **Health Checks**: Regular endpoint health monitoring

### Permission Checking (RBAC)

AssetCore standardizes permission checks across API routes and the web frontend using shared helpers.

System administrator terminology:
- `system_admin` is a user type (platform scope)
- `system_role` within `system_admin` is either `super_admin` (all permissions: `*:*`) or `support_admin` (read-focused support)

- Generic evaluator (shared): `src/lib/permissions.ts`
  - `checkPermissionsForContext(context, required, mode)` merges role-derived and explicit permissions and evaluates them.

- API routes (server): `src/lib/authz/api.ts`
  - `requireSystemAdmin(request)` validates JWT from `Authorization: Bearer <token>`, builds auth context, and enforces `system_admin`.
  - `requireSystemAdminWithPermissions(request, required, mode)` adds permission checks via the generic evaluator.
  - Usage in API routes: import from `@/lib/authz/api` and early-return with the provided `response`.

- Web/frontend (client/server components): `src/lib/authz/web.ts`
  - `hasUserPermissions(user, required, mode)` checks permissions for the current user context (e.g., from session or props).

Rules:
- API routes MUST use `@/lib/authz/api` guards (never read cookies; read the Authorization header only).
- Frontend MUST use `@/lib/authz/web` (no header parsing on the client).
- Roles map to permissions via `getRolePermissions(systemRole)`; `super_admin` maps to `*:*`.

Examples:
```ts
// API: require read permissions for users
import { requireSystemAdminWithPermissions } from '@/lib/authz/api';
export async function GET(request: NextRequest) {
  const auth = await requireSystemAdminWithPermissions(request, ['users:read', '*:read'], 'any');
  if (!auth.ok) return auth.response;
  // ...
}

// Web: check before showing a button
import { hasUserPermissions } from '@/lib/authz/web';
const canCreate = hasUserPermissions(user, 'users:create');
```
